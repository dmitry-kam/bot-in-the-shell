#  Bot in the Shell #
## Разворачиваем среду разработки ##
Клонируем проект, переходим в папку проекта и выполняем (скачивание установочного пакета ES может не 
работать без VPN, после установки ES в конфиге нужно поменять параметр cluster.initial_master_nodes 
на название своей виртуальной машины, если устанавливается локально):
> sudo bash install.sh

Должно развернуться окружение со всеми необходимыми пакетами. В дальнейшем при обновлении файлов Pipfile и 
Pipfile.lock в репозитории необходимо выполнить команду.

> pipenv shell | pipenv install

Будут установлены пакеты из Pipfile.lock. Далее необходимо создать (скопировать из примера) файл .env в 
корне проекта и сконфигурировать переменные окружения (этот файл используется по умолчанию при активации окружения).

Для использования интерпретатора Pipenv в PyCharm нужно выполнить команду, после чего в настройках IDE 
установить виртуальное окружение. После этого станут доступны для просмотра кода внешние библиотеки.
> pipenv --venv

В директории configs расположены различные заготовки конфигурационных файлов (например, для тестирования 
определенной стратегии, пары и т.д.). Чтобы подключить окружение с этим конфигом нужно выполнить команду:
> PIPENV_DOTENV_LOCATION=configs/.env.test pipenv shell

## Команды ##

Список предустановленных команд:
> pipenv scripts

Чтобы запустить команду:
> pipenv run scriptName

Другая информация по конфигурации окружения [здесь](https://docs.pipenv.org/advanced/#automatic-loading-of-env).

## Документация ##

При написании новых классов, функций и т.д. нужно описывать, что они делают при помощи многострочных комментариев

Возможно автоматически сгенерировать описание по списку скриптов (указываются от директории src в файле 
listForDocumentation.txt) при помощи команды:
> pipenv run generateDocumentation

Пока что примитивно. При необходимости доработаем.


## Бот ##

Главный класс при запуске подключает все инструменты (Redis, ES, Postgres), логгеры, конфиг согласно переменным 
окружения, стратегии-сигналы согласно конфигу. В последние прокидываются все подключения, чтобы дать возможность
каждому сигналу работать со всеми инструментами.

Таким образом, класс бота это точка управления, отвечающая за связь всех модулей, за управление логами, гибкое 
подключение и конечное решение о действиях на бирже. Сами классы для работы биржи и сигналы не знают и не должны
знать друг о друге, о модуле управления и режиме торговли. Сигнал зависит от времени (детерменированная от времени
функция) и своей внутренней логики (и внешнего конфига), которая позволяет любыми способами выдать решение о 
покупке/продаже (на уровне аргументов никакой взаимосвязи с ботом не должно быть).